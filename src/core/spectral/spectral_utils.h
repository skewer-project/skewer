#ifndef SKWR_CORE_SPECTRAL_SPECTRAL_UTILS_H_
#define SKWR_CORE_SPECTRAL_SPECTRAL_UTILS_H_

#include <algorithm>
#include <iostream>
#include <stdexcept>

#include "core/color.h"
#include "core/spectral/rgb2spec.h"
#include "core/spectral/spectral_curve.h"
#include "core/spectrum.h"
#include "srgb_spec_data.h"

namespace skwr {

inline RGB2Spec* g_rgb2spec_model = nullptr;

// Initialize from the embedded memory buffer
inline void InitSpectralModel() {
    if (!g_rgb2spec_model) {
        // Pass the array and length generated by xxd
        g_rgb2spec_model = rgb2spec_load_memory(srgb_spec, srgb_spec_len);

        if (!g_rgb2spec_model) {
            throw std::runtime_error("Failed to load embedded RGB2Spec model!");
        }
        std::clog << "[Spectral] Loaded embedded RGB2Spec model successfully.\n";
    }
}

// rgb2spec wrappers
inline SpectralCurve RGBToCurve(const RGB& color) {
    if (!g_rgb2spec_model) return SpectralCurve();

    RGB linear = ToLinear(color);

    // Find the maximum component
    float m = std::max({linear.r(), linear.g(), linear.b()});

    // Fast path for pure black (no emission)
    if (m <= 0.0f) {
        return SpectralCurve{{0.0f, 0.0f, 0.0f}, 0.0f};
    }

    // Extract intensity if it exceeds 1.0
    float scale = 1.0f;
    if (m > 1.0f) {
        scale = m;
        linear /= scale;
    }

    float rgb_array[3] = {std::max(0.0f, std::min(1.0f, linear.r())),
                          std::max(0.0f, std::min(1.0f, linear.g())),
                          std::max(0.0f, std::min(1.0f, linear.b()))};

    SpectralCurve curve;
    curve.scale = scale;  // Store the multiplier!
    rgb2spec_fetch(g_rgb2spec_model, rgb_array, curve.coeff);

    return curve;
}

inline Spectrum CurveToSpectrum(const SpectralCurve& curve, const SampledWavelengths& wl) {
    Spectrum result(0.0f);
    if (curve.scale <= 0.0f) return result;
    for (int i = 0; i < kNSamples; ++i) {
        result[i] = rgb2spec_eval_fast(const_cast<float*>(curve.coeff), wl.lambda[i]) * curve.scale;
    }
    return result;
}

// TODO: Refactor with tabulated data. This is only a temporary approximation
// Wyman approximation
inline float CIE_X(float lambda) {
    float x1 = (lambda - 442.0f) * ((lambda < 442.0f) ? 0.0624f : 0.0374f);
    float x2 = (lambda - 599.8f) * ((lambda < 599.8f) ? 0.0264f : 0.0323f);
    float x3 = (lambda - 501.1f) * ((lambda < 501.1f) ? 0.0490f : 0.0382f);
    return 0.362f * std::exp(-0.5f * x1 * x1) + 1.056f * std::exp(-0.5f * x2 * x2) -
           0.065f * std::exp(-0.5f * x3 * x3);
}

inline float CIE_Y(float lambda) {
    float y1 = (lambda - 568.8f) * ((lambda < 568.8f) ? 0.0213f : 0.0247f);
    float y2 = (lambda - 530.9f) * ((lambda < 530.9f) ? 0.0613f : 0.0322f);
    return 0.821f * std::exp(-0.5f * y1 * y1) + 0.286f * std::exp(-0.5f * y2 * y2);
}

inline float CIE_Z(float lambda) {
    float z1 = (lambda - 437.0f) * ((lambda < 437.0f) ? 0.0845f : 0.0278f);
    float z2 = (lambda - 459.0f) * ((lambda < 459.0f) ? 0.0385f : 0.0725f);
    return 1.217f * std::exp(-0.5f * z1 * z1) + 0.681f * std::exp(-0.5f * z2 * z2);
}

// TODO: Refactor to RGB file, preferably alongside the spectrum architecture refactor
inline RGB SpectrumToRGB(const Spectrum& spec, const SampledWavelengths& wl) {
    float X = 0.0f, Y = 0.0f, Z = 0.0f;

    // Monte Carlo Estimator: Integrate spectrum against the eye's XYZ response
    for (int i = 0; i < kNSamples; ++i) {
        float weight = 1.0f / (wl.pdf[i] * kNSamples);
        X += spec[i] * CIE_X(wl.lambda[i]) * weight;
        Y += spec[i] * CIE_Y(wl.lambda[i]) * weight;
        Z += spec[i] * CIE_Z(wl.lambda[i]) * weight;
    }

    // Normalize by the integral of the CIE Y curve (~106.8568)
    // Makes sure a pure white material (1.0 across the spectrum) stays 1.0 in RGB
    const float kCIE_Y_Integral = 106.8568f;
    X /= kCIE_Y_Integral;
    Y /= kCIE_Y_Integral;
    Z /= kCIE_Y_Integral;

    // Standard CIE XYZ to Linear sRGB Matrix
    float r = 3.2404542f * X - 1.5371385f * Y - 0.4985314f * Z;
    float g = -0.9692660f * X + 1.8760108f * Y + 0.0415560f * Z;
    float b = 0.0556434f * X - 0.2040259f * Y + 1.0572252f * Z;

    return RGB(r, g, b);
}

}  // namespace skwr

#endif  // SKWR_CORE_SPECTRAL_SPECTRAL_UTILS_H_
