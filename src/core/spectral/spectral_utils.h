#ifndef SKWR_CORE_SPECTRAL_SPECTRAL_UTILS_H_
#define SKWR_CORE_SPECTRAL_SPECTRAL_UTILS_H_

#include <algorithm>
#include <iostream>
#include <stdexcept>

#include "core/color.h"
#include "core/spectral/rgb2spec.h"
#include "core/spectral/spectral_curve.h"
#include "core/spectral/srgb_spec_data.h"
#include "core/spectrum.h"

namespace skwr {

inline RGB2Spec* g_rgb2spec_model = nullptr;

// Initialize from the embedded memory buffer
inline void InitSpectralModel() {
    if (!g_rgb2spec_model) {
        // Pass the array and length generated by xxd
        g_rgb2spec_model = rgb2spec_load_memory(srgb_spec, srgb_spec_len);

        if (!g_rgb2spec_model) {
            throw std::runtime_error("Failed to load embedded RGB2Spec model!");
        }
        std::clog << "[Spectral] Loaded embedded RGB2Spec model successfully.\n";
    }
}

// rgb2spec wrappers
inline SpectralCurve RGBToCurve(const RGB& color) {
    if (!g_rgb2spec_model) return SpectralCurve();

    RGB linear = ToLinear(color);
    float rgb_array[3] = {std::max(0.0f, std::min(1.0f, linear.r())),
                          std::max(0.0f, std::min(1.0f, linear.g())),
                          std::max(0.0f, std::min(1.0f, linear.b()))};

    SpectralCurve curve;
    rgb2spec_fetch(g_rgb2spec_model, rgb_array, curve.coeff);
    return curve;
}

inline Spectrum CurveToSpectrum(const SpectralCurve& curve, const SampledWavelengths& wl) {
    Spectrum result;
    for (int i = 0; i < kNSamples; ++i) {
        result[i] = rgb2spec_eval_precise(const_cast<float*>(curve.coeff), wl.lambda[i]);
    }
    return result;
}

}  // namespace skwr

#endif  // SKWR_CORE_SPECTRAL_SPECTRAL_UTILS_H_
